struct Light
{
    vec3 position;
    float intensity;
    vec3 color;
    int type;

    float range;
    vec2 invertedDirection;
    float cutoff;
};
uniform Light lights[32];
uniform int lightCount;
uniform int disableLighting;

vec4 calculateLights(vec4 albedo, vec3 normal, vec3 world_pos, vec2 view_pos, float mask)
{
    if (disableLighting == 1)
        return albedo;

    vec3 light;
    vec3 ambient;
    for (int i = 0; i < lightCount && i < 32; i++)
    {
        vec3 toLight = lights[i].position - world_pos;
        if (lights[i].type == 2)
        {
            ambient += clamp(lights[i].color * lights[i].intensity, 0, 1);
        }
        else if(lights[i].type == 0 || (lights[i].type == 1 && dot(normalize(toLight.xy), normalize(lights[i].invertedDirection)) > lights[i].cutoff)) 
        {       
            vec3 lightDir = normalize(toLight);

            //Diffuse
            float diff = max(dot(normal, lightDir), 0.0);
            vec3 diffuse = vec3(diff, diff, diff);

            //Attenuation
            float r = lights[i].range;
            float d = length(toLight.xy);
            float attenuation = log(1/d * r);
            if (d > lights[i].range)
                attenuation = 0;

            light += diffuse * attenuation * lights[i].intensity * lights[i].color;  
        }
    }

    return albedo * mask * vec4(ambient, 1) + albedo * vec4(light, 1);
}